# Баш-Онелинер (translate by deepl)
Я рад, что вы здесь! Несколько лет назад я занимался биоинформатикой и был поражен этими однословными командами bash, которые намного быстрее, чем мои скучные скрипты, время, сэкономленное благодаря изучению сочетаний клавиш командной строки и сценариев. В последние годы я работаю над облачными вычислениями и продолжаю записывать эти полезные команды здесь. Не все они односложные, но я прилагаю усилия, чтобы сделать их краткими и быстрыми. В основном я использую Ubuntu, Amazon Linux, RedHat, Linux Mint, Mac и CentOS, извините, если команды не работают в вашей системе.

Этот блог будет посвящен простым командам bash для анализа данных и обслуживания системы Linux, которые я приобрел во время работы и экзамена LPIC. Я извиняюсь, что нет подробных ссылок на все команды, но они, вероятно, взяты из уважаемых Google и Stack Overflow.

Английский и bash не являются моим родным языком, пожалуйста, поправьте меня в любое время, спасибо.
Если вы знаете другие классные команды, пожалуйста, научите меня!

Вот более стильная версия [Bash-Oneliner-EU](https://onceupon.github.io/Bash-Oneliner/)~.

## Удобные однострочники Bash

- [Terminal Tricks](#terminal-tricks)
- [Variable](#variable)
- [Math](#math)
- [Grep](#grep)
- [Sed](#sed)
- [Awk](#awk)
- [Xargs](#xargs)
- [Find](#find)
- [Условие и цикл](#condition-and-loop)
- [Time](#time)
- [Download](#download)
- [Random](#random)
- [Xwindow](#xwindow)
- [System](#система)
- [Hardware](#аппаратное обеспечение)
- [Networking](#networking)
- [Data Wrangling](#data-wrangling)
- [Другие](#others)

## Терминальные трюки

##### Использование клавиш Ctrl
```
Ctrl + n : то же, что и стрелка вниз.
Ctrl + p : то же, что и стрелка вверх.
Ctrl + r : начинает обратный поиск в истории команд (продолжайте нажимать Ctrl + r, чтобы двигаться назад).
Ctrl + s : остановить вывод на терминал.
Ctrl + q : возобновление вывода на терминал после Ctrl + s.
Ctrl + a : переход к началу строки.
Ctrl + e : перемещение в конец строки.
Ctrl + d : если вы что-то набрали, Ctrl + d удаляет символ под курсором, в противном случае происходит выход из текущей оболочки.
Ctrl + k : удалить весь текст от курсора до конца строки.
Ctrl + x + backspace : удалить весь текст от начала строки до курсора.
Ctrl + t : транспонировать символ перед курсором с символом под курсором, нажмите Esc + t, чтобы транспонировать два слова перед курсором.
Ctrl + w : вырезать слово перед курсором; затем Ctrl + y вставить его.
Ctrl + u : вырезать строку перед курсором; затем Ctrl + y вставить ее.
Ctrl + _ : отменить ввод.
Ctrl + l : эквивалентно очистить.
Ctrl + x + Ctrl + e : запуск редактора, определенного $EDITOR, для ввода вашей команды. Полезно для многострочных команд.
```
##### Изменить регистр
```bash
Esc + u
# переводит текст от курсора до конца слова в верхний регистр.
Esc + l
# переводит текст от курсора до конца слова в нижний регистр.
Esc + c
# переводит букву под курсором в верхний регистр, остальное слово - в нижний.
```
##### Номер истории выполнения (например, 53).
```bash
!53
```

##### Выполнить последнюю команду
```bash
!!
# запустите предыдущую команду с помощью sudo
sudo !!!
```

##### Выполните последнюю команду и измените какой-либо параметр, используя подстановку каретки (например, последняя команда: echo 'aaa' -> повторное выполнение как: echo 'bbb')
```bash
#last command: echo 'aaa'
^aaa^bbb

#echo 'bbb'
#bbb

#Обратите внимание, что будет заменен только первый aaa, если вы хотите заменить все 'aaa', используйте ':&' для повторения:
^aaa^bbb^:&
#or
!!:gs/aaa/bbb/

```

##### Запустите прошлую команду, которая начиналась с (например, cat filename)
```bash
!cat
# или
!c
# запустите cat filename снова
```

##### Bash globbing
```bash
# '*' служит "дикой картой" для расширения имени файла.
/etc/pa*wd #/etc/passwd

# '?' служит односимвольной "дикой картой" для расширения имени файла.
/b?n/?at #/bin/cat

# '[]' служит для поиска символа из диапазона.
ls -l [a-z]* # список всех файлов с алфавитом в имени файла.

# '{}' может использоваться для поиска имен файлов с более чем одним шаблоном
ls *.{sh,py}   #список всех файлов .sh и .py
```

##### Некоторые удобные переменные окружения
```
$0 :имя оболочки или сценария оболочки.
$1, $2, $3, ... :позиционные параметры.
$# :количество позиционных параметров.
$? :последний статус выхода из конвейера переднего плана.
$- :текущий набор опций для оболочки.
$$ :pid текущей оболочки (не под-оболочки).
$! :PID последней фоновой команды.

$DESKTOP_SESSION текущий менеджер дисплея.
$EDITOR предпочитаемый текстовый редактор.
$LANG текущий язык.
$PATH список каталогов для поиска исполняемых файлов (т.е. готовых к запуску программ).
$PWD текущий каталог
$SHELL текущая оболочка
$USER текущее имя пользователя
$HOSTNAME текущее имя хоста
```

## Переменная
[[назад к началу](#handy-bash-one-liners)]
##### Подстановка переменных в кавычках
```bash
# foo=bar
echo $foo
# bar
echo "$foo"
# bar
# одинарные кавычки приводят к тому, что переменные не расширяются
echo '$foo'
# $foo
# одинарные кавычки внутри двойных кавычек не отменяют расширения и являются частью вывода
echo "'$foo'"
# 'bar'
# удвоенные одинарные кавычки действуют как двойные кавычки, заставляя переменные расширяться
echo ''$foo''
# bar
```
##### Получение длины переменной
```bash
var="некоторая строка"
echo ${#var}
# 11
```
##### Получение первого символа переменной
```bash
var=строка
echo "${var:0:1}"
#s

# или
echo ${var%%"${var#?"}}
```

##### Удаление первой или последней строки из переменной
```bash
var="некоторая строка"
echo ${var:2}
#me string
```

##### Замена (например, удаление первого ведущего 0)
```bash
var="0050"
echo ${var[@]#0}
#050
```

##### Замена (например, заменить 'a' на ',')
```bash
{var/a/,}
```

##### Замена всех (например, заменить все 'a' на ',')
```bash
{var//a/,}
```

##### Grep строки со строками из файла (например, строки с 'stringA или 'stringB' или 'stringC')
```bash
#с grep
test="stringA stringB stringC"
grep ${test// /\\\\\|} file.txt
# превращая пробел в 'или' (\||) в grep
```

##### Для изменения регистра строки, хранящейся в переменной, на нижний регистр (Расширение параметров)
```bash
var=HelloWorld
echo ${var,,}
helloworld
```

##### Развернуть и затем выполнить переменную/аргумент
```bash
cmd="bar=foo"
eval "$cmd"
echo "$bar" # foo
```

## Математика
[[назад к началу](#handy-bash-one-liners)]
##### Арифметическое расширение в Bash (операторы: +, -, *, /, % и т.д.)
```bash
echo $((( 10 + 5 ))  #15
x=1
echo $(( x++ )) #1 , обратите внимание, что это все еще 1, так как это пост-инкремент
echo $(( x++ )) #2
echo $((( ++x )) #4 , обратите внимание, что это не 3, так как это пре-инкремент
echo $(( x-- )) #4
echo $((( x-- )) #3
echo $(( --x )) #1
x=2
y=3
echo $((( x ** y )) #8
```

##### Выведите простые коэффициенты числа (например, 50).
```bash
фактор 50
# 50: 2 5 5
```
##### Суммирование входного списка (например, seq 10)
```bash
seq 10|paste -sd+|bc
```

##### Суммирование файла (каждая строка в файле содержит только одно число)
```bash
awk '{s+=$1} END {print s}' filename
```

##### Вычитание столбцов
```bash
cat file| awk -F '\t' 'BEGIN {SUM=0}{SUM+=$3-$2}END{print SUM}'
```

##### Простая математика с помощью expr
```bash
expr 10+20 #30
expr 10\*20 #600
expr 30 \> 20 #1 (true)
```

##### Больше математики с bc
```bash
# Количество десятичных цифр/значащая цифра
echo "scale=2;2/3" | bc
#.66

# Оператор экспоненты
echo "10^2"| bc
#100

# Использование переменных
echo "var=5;--var"| bc
#4
```


## Grep
[[назад к началу](#handy-bash-one-liners)]

##### Тип grep
```bash
grep = grep -G # базовое регулярное выражение (BRE)
fgrep = grep -F # фиксированный текст, игнорирующий мета-символы
egrep = grep -E # расширенное регулярное выражение (ERE)
pgrep = grep -P # Perl-совместимые регулярные выражения (PCRE)
rgrep = grep -r # рекурсивный
```

##### Grep и подсчет количества пустых строк
```bash
grep -c "^$"
```

##### Поиск и возврат только целого числа
```bash
grep -o '[0-9]*
#or
grep -oP '\d*'
```
##### Поиск целого числа с определенным количеством цифр (например, 3)
```bash
grep '[0-9]\{3\}'
# или
grep -E '[0-9]{3}'
# или
grep -P '\d{3}'
```

##### Искать только IP-адрес
```bash
grep -Eo '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}''
# или
grep -Po '\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}'
```

##### Grep целое слово (например, 'target')
```bash
grep -w 'target'

#или используя RE
grep '\btarget\b'
```
##### Grep возвращает строки до и после совпадения (например, 'bbo')
```bash
# возвращает также 3 строки после совпадения
grep -A 3 'bbo'

# возвращает также 3 строки до совпадения
grep -B 3 'bbo'

# возвращает также 3 строки до и после совпадения
grep -C 3 'bbo'
```

##### Поиск строки, начинающейся с (например, 'S')
```bash
grep -o 'S.*'
```

##### Извлечение текста между словами (например, w1,w2)
```bash
grep -o -P '(?<=w1).*(?=w2)'
```

##### Grep строки без слова (например, 'bbo')
```bash
grep -v bbo filename
```

##### Поиск строк, не начинающихся со строки (например, #)
```bash
grep -v '^#' file.txt
```

##### Искать переменные с пробелом внутри (например, myvar="some strings")
```bash
grep "$myvar" filename
#не забудьте заключить переменную в кавычки!
```

##### Искать только одно/первое совпадение (например, 'bbo')
```bash
grep -m 1 bbo filename
```

##### Искать и возвращать номер совпадающей строки (например, 'bbo')
```bash
grep -c bbo filename
```

##### Подсчет вхождений (например, три раза строка считается три раза)
```bash
grep -o bbo filename |wc -l
```

##### Нечувствительный к регистру grep (например, 'bbo'/'BBO'/'Bbo')
```bash
grep -i "bbo" filename
```

##### Выявить совпадение (например, 'bbo')!
```bash
grep --color bbo filename
```

##### Grep ищет все файлы в каталоге (например, 'bbo')
```bash
grep -R bbo /path/to/directory
# или
grep -r bbo /path/to/directory
```

##### Поиск всех файлов в каталоге, не выводите имена файлов (например, 'bbo')
```bash
grep -rh bbo /path/to/directory
```

##### Поиск всех файлов в каталоге, вывод ТОЛЬКО имен файлов с совпадениями (например, 'bbo')
```bash
grep -rl bbo /path/to/directory
```

##### Grep OR (например, A или B или C или D)
```
grep 'A\|B\|C\|D'
```

##### Grep AND (например, A и B)
```bash
grep 'A.*B'
```

##### Regex любой отдельный символ (например, ACB или AEB)
```bash
grep 'A.B'
```

##### Regex с определенным символом или без него (например, color или color)
```bash
grep 'colou\?r'
```

##### Перепечатка всего содержимого файлаА из файлаВ
```bash
grep -f fileA fileB
```

##### Найти вкладку
```bash
grep $'\t'
```

##### Поиск переменной из переменной
```bash
$echo "$long_str"|grep -q "$short_str"
if [ $? -eq 0 ]; then echo 'found'; fi
#grep -q выведет 0, если совпадение найдено
#не забудьте добавить пробел между []!
```

##### Grep-строки между скобками()
```bash
grep -oP '\(\K[^\)]+'
```

##### Поиск количества символов с известными строками между ними (например, AAEL000001-RA)
```bash
grep -o -w "\w\{10\}\-R\w\{1\}"
# \w слово символ [0-9a-zA-Z_] \W не слово символ
```

##### Пропустить каталог (например, 'bbo')
```bash
grep -d skip 'bbo' /path/to/files/*
```



## Sed
[[назад к началу](#handy-bash-one-liners)]
##### Удалите 1-ю строку
```bash
sed 1d filename
```

##### Удалить первые 100 строк (удалить строки 1-100)
```bash
sed 1,100d filename
```

##### Удалите строки со строкой (например, 'bbo')
```bash
sed "/bbo/d" filename
# нечувствительно к регистру:
sed "/bbo/Id" filename
```

##### Удалите строки, n-й символ которых не равен значению (например, 5-й символ не равен 2).
```bash
sed -E '/^.{5}[^2]/d'
#aaaa2aaa (вы можете остаться)
#aaaa1aaa (удалить!)
```

##### Редактирование infile (редактирование и сохранение в файл), (например, удаление строк с 'bbo' и сохранение в файл)
```bash
sed -i "/bbo/d" filename
```

##### При использовании переменной (например, $i), используйте двойные кавычки " ".
```bash
# например, добавьте >$i к первой строке (чтобы сделать файл FASTA для биоинформатики)
sed "1i >$i"
# обратите внимание на двойные кавычки! В других примерах можно использовать одинарные кавычки, но здесь - ни в коем случае!
# '1i' означает вставить в первую строку.
```

##### Одновременное использование переменной окружения и шаблона конца строки.
```bash
# Используйте обратную косую черту для шаблона конца строки $, и двойные кавычки для выражения переменной
sed -e "\$s/\$/\n+--$3--+/"
```

##### Удаление/удаление пустых строк
```bash
sed '/^\s*$/d'

# или

sed '/^$/d'
```
##### Удаление/удаление последней строки
```bash
sed '$d'
```

##### Удаление/удаление последнего символа из конца файла
```bash
sed -i '$ s/.$//' filename
```

##### Добавить строку в начало файла (например, "\[")
```bash
sed -i '1s/^/[/' file
```

##### Добавить строку в определенный номер строки (например, добавить 'something' в строку 1 и строку 3)
```bash
sed -e '1isomething' -e '3isomething'
```

##### Добавьте строку в конец файла (например, "]")
```bash
sed '$s/$/]/' filename
```
##### Добавить новую строку в конец
```bash
sed '$a\'
```

##### Добавьте строку в начало каждой строки (например, 'bbo')
```bash
sed -e 's/^/bbo/' file
```

##### Добавьте строку в конец каждой строки (например, "}")
```bash
sed -e 's/$/\}\]/' имя файла
```

##### Добавить \n через каждый n-ый символ (например, через каждый 4-й символ)
```bash
sed 's/.\{4\}/&\n/g'
```

##### Конкатенировать/комбинировать/объединять файлы с разделителем и следующей строкой (например, разделять ",")
```bash
sed -s '$a,' *.json > all.json
```

##### Подстановка (например, заменить A на B)
```bash
sed 's/A/B/g' filename
```

##### Подстановка с подстановочным знаком (например, заменить строку, начинающуюся с aaa= на aaa=/my/new/path)
```bash
sed "s/aaa=.*/aaa=\/my\/new\/path/g"
```

##### Выберите строки, начинающиеся со строки (например, 'bbo')
```bash
sed -n '/^@S/p'
```
##### Удалить строки, начинающиеся со строки (например, 'bbo')
```bash
sed '/bbo/d' filename
```

##### Вывести/получить/обрезать диапазон строк (например, строка 500-5000)
```bash
sed -n 500,5000p filename
```

##### Печать каждой n-ой строки
```bash
sed -n '0~3p' filename

# catch 0: start; 3: step
```

##### Выводите каждую нечетную # строку
```bash
sed -n '1~2p'
```
##### Выведите каждую третью строку, включая первую.
```bash
sed -n '1p;0~3p'
```
##### Удаление пробельных символов и табуляции
```bash
sed -e 's/^[ \t]*//'
# Заметьте пробел перед '\t'!!!
```

##### Удаление только ведущих пробелов
```bash
sed 's/ *//'

# обратите внимание на пробел перед '*'!!!
```

##### Удаление завершающих запятых
```bash
sed 's/,$//g'
```

##### Добавьте колонку в конец
```bash
sed "s/$/\t$i/"
# $i - это значение, которое вы хотите добавить.

# Чтобы добавить имя файла в каждый последний столбец файла
for i in $(ls);do sed -i "s/$/\t$i/" $i;done
```

##### Добавить расширение имени файла в последний столбец.
```bash
for i in T000086_1.02.n T000086_1.02.p;do sed "s/$/\t${i/*./}/" $i;done >T000086_1.02.np
```

##### Удалить новую строку\ следующую строку
```bash
sed ':a;N;$!ba;s/\n//g'
```

##### Вывести определенную строку (например, 123-ю строку)
```bash
sed -n -e '123p'
```

##### Выведите ряд строк (например, от 10-й до 33-й строки)
```bash
sed -n '10,33p' <filename
```

##### Изменить разделитель
```bash
sed 's=/=/=\\\\/=g'
```

##### Заменить подстановочным знаком (например, A-1-e или A-2-e или A-3-e....)
```bash
sed 's/A-.*-e//g' filename
```

##### Удалить последний символ файла
```bash
sed '$ s/.$//'
```

##### Вставить символ в указанную позицию файла (например, AAAAAA --> AAA#AAA)
```bash
sed -r -e 's/^.{3}/&#/' file
```


## Awk
[[назад к началу](#handy-bash-one-liners)]

##### Установите табуляцию в качестве разделителя полей
```bash
awk -F $'\t'
```

##### Вывод в виде разделения табуляцией (также как разделитель полей)
```bash
awk -v OFS='\t'
```

##### Передача переменной
```bash
a=bbo;b=obb;
awk -v a="$a" -v b="$b" "$1==a && $10=b" filename
```

##### Выведите номер строки и количество символов в каждой строке.
```bash
awk '{print NR,length($0);}' filename
```

##### Найти количество столбцов
```bash
awk '{print NF}'
```

##### Обратный порядок столбцов
```bash
awk '{print $2, $1}'
```

##### Проверка наличия запятой в колонке (например, в колонке $1)
```bash
awk '$1~/,/ {print}'
```

##### Разделение и выполнение цикла for
```bash
awk '{split($2, a,",");for (i in a) print $1"\t "a[i]}' filename
```

##### Вывести все строки до n-го вхождения строки (например, остановить печать строк, когда 'bbo' появляется 7 раз)
```bash
awk -v N=7 '{print}/bbo/&& --N<=0 {exit}'
```

##### Выведите имя файла и последнюю строку всех файлов в каталоге
```bash
ls|xargs -n1 -I file awk '{s=$0};END{print FILENAME,s}' file
```

##### Добавить строку в начало столбца (например, добавить "chr" в столбец $3)
```bash
awk 'BEGIN{OFS="\t"}$3="chr»$3’
```

##### Удалите строки со строкой (например, 'bbo')
```bash
awk '!/bbo/' file
```

##### Удалить последний столбец
```bash
awk 'NF{NF-=1};1' файл
```

##### Использование и значение NR и FNR
```bash
# Например, есть два файла:
# fileA:
# a
# b
# c
# fileB:
# d
# e
awk 'print FILENAME, NR,FNR,$0}' fileA fileB
# fileA 1 1 a
# fileA 2 2 b
# fileA 3 3 c
# fileB 4 1 d
# fileB 5 2 e
```

##### AND gate
```bash
# Например, есть два файла:
# fileA:
# 1 0
# 2 1
# 3 1
# 4 0
# fileB:
# 1 0
# 2 1
# 3 0
# 4 1

awk -v OFS='\t' 'NR=FNR{a[$1]=$2;next} NF {print $1,((a[$1]=$2)? $2: "0")}' fileA fileB
# 1 0
# 2 1
# 3 0
# 4 0
```

##### Округлите все числа файла (например, до 2 значащей цифры).
```bash
awk '{while (match($0, /[0-9]+\[0-9]+/)){
    \printf "%s%.2f", substr($0,0,RSTART-1),substr($0,RSTART,RLENGTH)
    \$0=substr($0, RSTART+RLENGTH)
    \}
    \print
    \}'
```

##### Присвоить номер/индекс каждой строке
```bash
awk '{printf("%s\t%s\n",NR,$0)}’
```

##### Объедините данные столбцов в строки
```bash
# Например, разделите следующее содержимое:
# David cat,dog
# в
# David cat
# Давид собака

awk '{split($2,a,",");for(i in a)print $1"\t "a[i]}' file

# Деталь здесь: http://stackoverflow.com/questions/33408762/bash-turning-single-comma-separated-column-into-multi-line-string
```

##### Усреднение файла (каждая строка в файле содержит только одно число)
```bash
awk '{s+=$1}END{print s/NR}'
```

##### Печать поля, начинающегося со строки (например, Linux)
```bash
awk '$1 ~ /^Linux/'
```

##### Сортировка строки (например, 1 40 35 12 23 --> 1 12 23 35 40)
```bash
awk ' {split( $0, a, "\t" ); asort( a ); for( i = 1; i <= length(a); i++ ) printf( "%s\t", a[i] ); printf( "\n" ); }''
```

##### Вычитаем значения предыдущей строки (добавляем столбец6, который равен столбцу4 минус последний столбец5)
```bash
awk '{$6 = $4 - prev5; prev5 = $5; print;}'
```

## Xargs
[[назад к началу](#handy-bash-one-liners)]

##### Установить табуляцию в качестве разделителя (по умолчанию:пробел)
```bash
xargs -d\t
```

##### Запрос команд перед их выполнением
```bash
ls|xargs -L1 -p head
```

##### Отображение 3 элементов в строке
```bash
echo 1 2 3 4 5 6| xargs -n 3
# 1 2 3
# 4 5 6

```
##### Подсказка перед выполнением
```bash
echo a b c |xargs -p -n 3
```

##### Печать команды вместе с выводом
```bash
xargs -t abcd
# bin/echo abcd
# abcd

```
##### С помощью find и rm
```bash
find . -name "*.html"|xargs rm

# при использовании обратного знака
rm ``find . -name "*.html"`
```

##### Удаление файлов с пробелами в имени файла (например, "hello 2001")
```bash
find . -name "*.c" -print0|xargs -0 rm -rf
```

##### Показать ограничения на длину командной строки
```bash
xargs --show-limits
# Вывод с моего Ubuntu:
# Ваши переменные окружения занимают 3653 байта.
# Верхний предел POSIX на длину аргумента (эта система): 2091451
# POSIX наименьший допустимый верхний предел длины аргумента (все системы): 4096
# Максимальная длина команды, которую мы можем реально использовать: 2087798
# Размер буфера команд, который мы фактически используем: 131072
# Максимальный параллелизм (--max-procs должно быть не больше): 2147483647
```

##### Переместить файлы в папку
```bash
find . -name "*.bak" -print 0|xargs -0 -I {} mv {} ~/old

# или
find . -name "*.bak" -print 0|xargs -0 -I file mv file ~/old
```

##### Переместите первый 100-й файл в каталог (например, d1).
```bash
ls |head -100|xargs -I {} mv {} d1
```

##### Parallel
```bash
time echo {1..5} |xargs -n 1 -P 5 sleep

# намного быстрее, чем:
time echo {1..5} |xargs -n 1 sleep
```

##### Скопируйте все файлы из A в B
```bash
find /dir/to/A -type f -name "*.py" -print 0| xargs -0 -r -I file cp -v -p file --target-directory=/path/to/B

# v: verbose|
# p: сохранить детали (например, владельца)

```

##### С помощью sed
```bash
ls |xargs -n1 -I file sed -i '/^Pos/d' file
```

##### Добавьте имя файла в первую строку файла
```bash
ls |sed 's/.txt//g'|xargs -n1 -I file sed -i -e '1 i\>file\' file.txt
```

##### Подсчитать все файлы
```bash
ls |xargs -n1 wc -l
```

##### Превратите вывод в одну строку
```bash
ls -l| xargs
```

##### Подсчет файлов в каталогах
```bash
echo mso{1..8}|xargs -n1 bash -c 'echo -n "$1:"; ls -la "$1"| grep -w 74 |wc -l' -...
# "--" сигнализирует о конце опций и отображает дальнейшую обработку опций
```

##### Подсчет строк во всех файлах, также подсчет общего количества строк
```bash
ls|xargs wc -l
```
##### Xargs и grep
```bash
cat grep_list |xargs -I{} grep {} filename
```

##### Xargs и sed (замена всех старых ip-адресов на новые ip-адреса в каталоге /etc)
```bash
grep -rl '192.168.1.111' /etc | xargs sed -i 's/192.168.1.111/192.168.2.111/g'
```


## Найти
[[назад к началу](#handy-bash-one-liners)]
##### Список всех подкаталогов/файлов в текущем каталоге
```bash
найти
```

##### Список всех файлов в текущем каталоге
```bash
найти . -type f
```

##### Список всех каталогов под текущим каталогом
```bash
найти -type d
```

##### Редактирование всех файлов в текущем каталоге (например, заменить 'www' на 'ww')
```bash
find . -name '*.php' -exec sed -i 's/www/w/g' {} \;

# если нет подкаталога
замените "www" "w" - *
# пробел перед *
```
##### Поиск и вывод только имени файла (например, "mso")
```bash
find mso*/ -name M* -printf "%f\n"
```

##### Поиск больших файлов в системе (например, >4G)
```bash
find / -type f -size +4G
```

##### Найти и удалить файл размером менее (например, 74 байта)
```bash
find . -name "*.mso" -size -74c -delete.

# M для MB и т.д.
```

##### Поиск пустых (0 байт) файлов
```bash
find . -type f -empty
# для дальнейшего удаления всех пустых файлов
find . -type f -empty -delete
```

##### Рекурсивный подсчет всех файлов в каталоге
```bash
find . -type f | wc -l
```

## Условие и цикл
[[назад к началу](#handy-bash-one-liners)]

##### Оператор If
```bash
# цикл if и else для поиска соответствия строк
if [[ "$c" == "read" ]]; then outputdir="seq"; else outputdir="write" ; fi

# Проверьте, содержит ли myfile строку 'test':
if grep -q hello myfile; then echo -e "файл содержит строку!" ; fi

# Проверьте, является ли mydir каталогом, перейдите в него и сделайте другие вещи:
if cd mydir; then
  echo 'некоторое содержимое' >myfile
else
  echo >&2 "Фатальная ошибка. Этот скрипт требует наличия mydir."
fi

# если переменная равна null
if [ ! -s "myvariable" ]; then echo -e "variable is null!" ; fi
# Истина длины, если "STRING" равен нулю.

# Используя команду test (такую же, как []), проверьте, является ли длина переменной ненулевой
test -n "$myvariable" && echo myvariable is "$myvariable" || echo myvariable is not set

# Проверьте, существует ли файл
if [ -e 'filename' ]
then
  echo -e "Файл существует!"
fi

# Проверьте, существует ли файл, но также включая символические ссылки:
if [ -e myfile ] || [ -L myfile ]
, тогда
  echo -e "файл существует!"
fi

# Проверьте, больше или равно ли значение x 5
if [ "$x" -ge 5 ]; then echo -e "больше или равно 5!" ; fi

# Проверьте, больше или равно ли значение x 5, в bash/ksh/zsh:
if ((x >= 5)); then echo -e "greater or equal than 5!" ; fi

# Используйте (( )) для арифметических операций
if ((j==u+2)); then echo -e "j==u+2!!!" ; fi

# Используйте [[ ]] для сравнения
if [[ $age -gt 21 ]]; then echo -e "forever 21!!!" ; fi

```

[Больше команд if](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html)

##### For loop
```bash
# Выдаем эхом имя файла в текущем каталоге
for i in $(ls); do echo file $i;done
#or
for i in *; do echo file $i; done

# Сделать каталоги перечисленными в файле (например, myfile)
for dir in $(<myfile); do mkdir $dir; done

# Нажмите любую клавишу для продолжения каждого цикла
for i in $(cat tpc_stats_0925.log |grep failed|grep -o '\query\w\{1,2\}');do cat ${i}.log; read -rsp $'Press any key to continue...\n' -n1 key;done

# Печать файла построчно при нажатии клавиши,
oifs="$IFS"; IFS=$'\n'; for line in $(cat myfile); do ...; done
while read -r line; do ...; done <myfile

#Если в строке только одно слово, просто
for line in $(cat myfile); do echo $line; read -n1; done

#Пройтись по массиву
for i in "${arrayName[@]}"; do echo $i;done

```

##### While loop,
```bash
# Вычитание столбцов из файла (например, файл с 3 столбцами)
while read a b c; do echo $(($c-$b));done < < <(head filename)
# между двумя '<' стоит пробел

# Суммируем вычитание столбцов
i=0; while read a b c; do ((i+=$c-$b)); echo $i; done < <(head filename))

# Продолжайте проверять запущенный процесс (например, perl) и запускайте другой новый процесс (например, python) сразу после него. (ЛУЧШЕ использовать команду wait! Ctrl+F 'wait')
while [[ $(pidof perl) ]];do echo f;sleep 10;done && python timetorunpython.py
```

##### switch (case in bash)
```bash
прочитать тип;
case $type in
  '0')
    echo 'how'
    ;;
  '1')
    echo 'are'
    ;;
  '2')
    echo 'you'
    ;;
esac
```

## Время
[[назад к началу](#handy-bash-one-liners)]

##### Узнайте время, необходимое для выполнения команды.
```bash
time echo hi
```

##### Подождите некоторое время (например, 10 с)
```bash
sleep 10
```

##### Выведите дату с форматированием
```bash
дата +%F
# 2020-07-19

# или
date +'%d-%b-%Y-%H:%M:%S'
# 10-Apr-2020-21:54:40

# Возвращает текущее время с наносекундами.
date +"%T.%N"
# 11:42:18.664217000  

# Получение секунд с эпохи (1 января 1970 года) для заданной даты (например, 16 марта 2021 года)
date -d "Mar 16 2021" +%s
# 1615852800
# или
date -d "Tue Mar 16 00:00:00 UTC 2021"  +%s
# 1615852800  

# Преобразуйте количество секунд с эпохи обратно в дату
date --date @1615852800
# Tue Mar 16 00:00:00 UTC 2021

```

##### ожидание произвольной длительности (например, сон 1-5 секунд, как добавление джиттера)
```bash
sleep $[ ( $RANDOM % 5 ) + 1 ]
```

##### Выйти из учетной записи через определенный период времени (например, 10 секунд)
```bash
TMOUT=10
#как только вы установите эту переменную, таймер выхода из системы начнет работать!
```

##### Установите, как долго вы хотите выполнять команду
```bash
#Это запустит команду 'sleep 10' всего на 1 секунду.
timeout 1 sleep 10
```

##### Задайте время выполнения команды (например, через 1 минуту).
```bash
at now + 1min # единицами времени могут быть минуты, часы, дни или недели
предупреждение: команды будут выполняться с помощью /bin/sh
at> echo hihigithub >~/itworks
at> <EOT> # нажмите Ctrl + D для выхода
задание 1 at Wed Apr 18 11:16:00 2018
```


## Загрузка
[[вернуться к началу](#handy-bash-one-liners)]

##### Скачайте содержимое этого README.md (того, который вы сейчас просматриваете)
```bash
curl https://raw.githubusercontent.com/onceupon/Bash-Oneliner/master/README.md | pandoc -f markdown -t man | man -l -...

# или w3m (текстовый веб-браузер и пейджер)
curl https://raw.githubusercontent.com/onceupon/Bash-Oneliner/master/README.md | pandoc | w3m -T text/html

# или с помощью emacs (в текстовом редакторе emac)
emacs --eval '(org-mode)' --insert <(curl https://raw.githubusercontent.com/onceupon/Bash-Oneliner/master/README.md | pandoc -t org)

# или с помощью emacs (в терминале, выход с помощью Ctrl + x, затем Ctrl + c)
emacs -nw --eval '(org-mode)' --insert <(curl https://raw.githubusercontent.com/onceupon/Bash-Oneliner/master/README.md | pandoc -t org)
```

##### Загрузите все со страницы
```bash
wget -r -l1 -H -t1 -nd -N -np -A mp3 -e robots=off http://example.com

# -r: рекурсия и загрузка всех ссылок на странице
# -l1: только ссылки одного уровня
# -H: span host, посещать другие хосты
# -t1: количество повторных попыток
# -nd: не создавать новые каталоги, скачивать сюда
# -N: включить временную метку
# -nd: нет родителя
# -A: тип (разделять по ,)
# -e robots=off: игнорировать файл robots.txt, который не дает wget завалить сайт, извините example.com
```

##### Загрузка файла в веб и скачивание (https://transfer.sh/)
```bash
# Загрузите файл (например, filename.txt):
curl --upload-file ./filename.txt https://transfer.sh/filename.txt
# Вышеуказанная команда вернет URL, например: https://transfer.sh/tG8rM/filename.txt

# Далее вы можете скачать его:
curl https://transfer.sh/tG8rM/filename.txt -o filename.txt
```

##### Загрузите файл, если необходимо
```bash
data=file.txt
url=http://www.example.com/$data
if [ ! -s $data ];then
    echo "downloading test data..."
    wget $url
fi
```

##### Wget на имя файла (если имя длинное)
```bash
wget -O filename "http://example.com"
```

##### Wget файлов в папку
```bash
wget -P /path/to/directory "http://example.com"
```

##### Дайте команду curl следовать за любым перенаправлением, пока оно не достигнет конечного пункта назначения:
```bash
curl -L google.com
```

## Random
[[назад к началу](#handy-bash-one-liners)]
##### Случайная генерация пароля (например, сгенерировать 5 паролей длиной 13)
```bash
sudo apt install pwgen
pwgen 13 5
#sahcahS9dah4a xieXaiJaey7xa UuMeo0ma7eic9 Ahpah9see3zai acerae7Huigh7
```

##### Случайная выборка 100 строк из файла
```bash
shuf -n 100 имя файла
```

##### Случайный порядок (счастливый жребий)
```bash
for i in a b c d e; do echo $i; done | shuf
```

##### Эхо серии случайных чисел между диапазонами (например, перетасовать числа от 0-100, затем выбрать 15 из них случайным образом)
```bash
shuf -i 0-100 -n 15
```

##### Эхо случайного числа
```bash
echo $RANDOM
```

##### Случайное число от 0-9
```bash
echo $((RANDOM % 10))
```

##### Случайный от 1-10
```bash
echo $(((RANDOM %10)+1))
```

## Xwindow
[[назад к началу](#handy-bash-one-liners)]

X11 GUI-приложения! Вот несколько GUI-инструментов для вас, если вам наскучило окружение, состоящее только из текста.

##### Включите переадресацию X11, чтобы использовать графические приложения на серверах.
```bash
ssh -X имя_пользователя@ip_адрес

# или настройка через xhost
# --> Установите следующее для Centos:
# xorg-x11-xauth
# xorg-x11-fonts-*
# xorg-x11-utils
```

##### Маленькие инструменты xwindow
```bash
xclock
xeyes
xcowsay
```

##### Открываем картинки/изображения с ssh-сервера
```bash
1. ssh -X имя_пользователя@ip_адрес
2. apt-get install eog
3. eog picture.png
```

##### Просмотр видео на сервере
```bash
1. ssh -X имя_пользователя@ip_адрес
2. sudo apt install mpv
3. mpv myvideo.mp4
```

##### Использование gedit на сервере (GUI редактор)
```bash
1. ssh -X имя_пользователя@ip_адрес
2. apt-get install gedit
3. gedit filename.txt
```

##### Открыть PDF файл с ssh сервера
```bash
1. ssh -X имя_пользователя@ip_адрес
2. apt-get install evince
3. evince filename.pdf
```

##### Использование браузера google-chrome с ssh-сервера
```bash
1. ssh -X имя_пользователя@ip_адрес
2. apt-get install libxss1 libappindicator1 libindicator7
3. wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
4. sudo apt-get install -f
5. dpkg -i google-chrome*.deb
6. google-chrome
 ```


## Система
[[назад к началу](#handy-bash-one-liners)]

##### Работа с историей yum
```bash
# Вывести историю yum (например, установка, обновление)
sudo yum history
# Пример вывода:
# Загруженные плагины: extras_suggestions, langpacks, priorities, update-motd
# ID | Логин пользователя | Дата и время | Действие(и) | Изменено
# ---------------------------------------
# 11 | ... <myuser> | 2020-04-10 10:57 | Install | 1 P<
# 10 | ... <myuser> | 2020-03-27 05:21 | Установить | 1 >P
# 9 | ... <myuser> | 2020-03-05 11:57 | I, U | 56 *<
# ...

# Показать более подробную информацию об истории yum (например, история #11)
sudo yum history info 11

# Отменить историю yum (например, историю #11, это приведет к деинсталляции некоторых пакетов)
sudo yum history undo 11
```

##### Аудит файлов, чтобы узнать, кто внес изменения в файл [только для систем на базе RedHat].
```bash
# Для рекурсивного аудита каталога на предмет изменений (например, myproject)
auditctl -w /path/to/myproject/ -p wa

# Если вы удалите файл с именем "VIPfile", удаление будет записано в /var/log/audit/audit.log
sudo grep VIPfile /var/log/audit/audit.log
#type=PATH msg=audit(1581417313.678:113): item=1 name="VIPfile" inode=300115 dev=ca:01 mode=0100664 ouid=1000 ogid=1000 rdev=00:00 nametype=DELETE cap_fp=00000000 cap_fi=00000000 cap_fe=0 cap_fver=0
```

##### Проверьте, включен ли SELinux.
```bash
sestatus
# SELinux status: enabled
# SELinuxfs mount:                /sys/fs/selinux
# SELinux root directory:         /etc/selinux
# Имя загруженной политики: target
# Текущий режим: усиление
# Режим из файла конфигурации: enforcing
# Политика MLS статус: включена
# Статус политики deny_unknown: разрешено
# Максимальная версия политики ядра: 31
```

##### Генерируем открытый ключ из закрытого ключа
```bash
ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub
```

##### Скопируйте ваш открытый ключ по умолчанию удаленному пользователю.
```bash
ssh-copy-id <имя_пользователя>@<IP_сервера>
# затем вам нужно ввести пароль
# и в следующий раз вам не нужно будет вводить пароль при ssh к этому пользователю
```

##### Скопируйте открытый ключ по умолчанию удаленному пользователю, используя необходимый закрытый ключ (например, используйте ваш ключ mykey.pem для копирования вашего id_rsa.pub удаленному пользователю)
```bash
# перед тем, как использовать mykey.pem для ssh к удаленному пользователю.
ssh-copy-id -i ~/.ssh/id_rsa.pub -o "IdentityFile ~/Downloads/mykey.pem" <имя_пользователя>@<IP_сервера>
# теперь вам не нужно использовать ключ для ssh для этого пользователя.
```

##### SSH Agent Forwarding
```bash
# Чтобы взять с собой ключ при ssh на серверА, а затем ssh на серверВ с сервераА, используя ключ.
ssh-agent
ssh-add /path/to/mykey.pem
ssh -A <имя пользователя>@<IP_of_serverA>
# Далее можно выполнить ssh на серверB
ssh <имя пользователя>@<IP_of_serverB>
```

##### Установите пользователя и ключ по умолчанию для хоста при использовании SSH
```bash
# добавьте следующее в ~/.ssh/config
Хост myserver
  Пользователь myuser
  IdentityFile ~/path/to/mykey.pem

# Далее, вы можете запустить "ssh myserver" вместо "ssh -i ~/path/to/mykey.pem myuser@myserver"
```

##### Следите за последними логами сервиса.
```bash
journalctl -u <имя_службы> -f
```

##### Устраните зомби
```bash
# Зомби уже мертв, поэтому вы не можете его убить. Вы можете уничтожить зомби, убив его родителя.
# Сначала найдите PID зомби.
ps aux| grep 'Z'
# Затем найдите PID родителя зомби.
pstree -p -s <zombie_PID>
# Затем вы можете убить его родителя, и вы заметите, что зомби исчез.
sudo kill 9 <parent_PID>
```
###### Показать использование памяти
```bash
free -c 10 -mhs 1
# вывести 10 раз с интервалом в 1 секунду
```

##### Показать статистику CPU и IO для устройств и разделов.
```bash
# обновлять каждую секунду
iostat -x -t 1
```

##### Отображение использования пропускной способности сетевого интерфейса (например, enp175s0f0)
```bash
iftop -i enp175s0f0
```

##### Узнать, как долго работает система и количество пользователей.
```bash
uptime
```

##### Проверить, запущен ли root
```bash
if [ "$EUID" -ne 0 ]; then
        echo "Пожалуйста, запустите это от имени root"
        exit 1
fi
```
##### Изменение оболочки пользователя (например, bonnie)
```bash
chsh -s /bin/sh bonnie
# /etc/shells: действительные оболочки для входа в систему
```

##### Изменить root / fake root / jail (например, изменить root на newroot)
```bash
chroot /home/newroot /bin/bash

# Для выхода из chroot
exit
```
##### Отображение состояния файла (размер; время доступа, изменения, модификации и т.д.) файла (например, filename.txt)
```bash
stat filename.txt
```

##### Снимок текущих процессов
```bash
ps aux
```

##### Отображение дерева процессов
```bash
pstree
```

##### Найти максимальное количество процессов
```bash
cat /proc/sys/kernel/pid_max
```

##### Печать или управление кольцевым буфером ядра
```bash
dmesg
```

##### Показать IP-адрес
```bash
$ip add show

# или
ifconfig
```

##### Выведите предыдущий и текущий уровень выполнения SysV.
```bash
runlevel

# или
who -r
```

##### Изменение уровня SysV runlevel (например, 5)
```bash
init 5
#or
telinit 5
```

##### Отображение всех доступных сервисов на всех уровнях выполнения,
```bash
chkconfig -list
# update-rc.d эквивалент chkconfig в ubuntu
```

##### Проверка версии системы
```bash
cat /etc/*-release
```

##### Linux Programmer's Manuel: hier- описание иерархии файловой системы
```bash
man hier
```

##### Управление менеджером систем и служб systemd.
```bash
# Например, проверьте статус службы cron
systemctl status cron.service

# например, остановить службу cron
systemctl stop cron.service
```

##### List job
```bash
jobs -l
```

##### Запуск программы с измененным приоритетом (например, ./test.sh)
```bash
# значение nice регулируется от -20 (наиболее благоприятное) до +19
# чем приятнее приложение, тем ниже приоритет.
# По умолчанию приятность: 10; приоритет по умолчанию: 80

nice -10 ./test.sh
```

##### Export PATH
```bash
export PATH=$PATH:~/path/you/want
```

##### Сделать файл исполняемым
```bash
chmod +x filename
# теперь вы можете открыть ./filename, чтобы выполнить его
```

##### Печать системной информации
```bash
uname -a

# Проверьте аппаратную платформу системы (x86-64)
uname -i
```

##### Серфинг в сети
```bash
ссылки www.google.com
```

##### Добавить пользователя, установить passwd
```bash
useradd имя пользователя
passwd имя пользователя
```

##### Редактирование переменной PS1 для bash (например, отображение всего пути)
```bash
1. vi ~/.bash_profile
2. export PS1='\u@\h:\w\$'
# $PS1 - это переменная, определяющая оформление и стиль командного интерпретатора.
# Вы можете использовать эмодзи и добавить метку времени к каждой подсказке, используя следующее значение:
# export PS1="\t@🦁:\w\$ "
3. источник ~/.bash_profile
```

##### Редактирование параметров окружения (например, псевдонима)
```bash
1. vi ~/.bash_profile
2. alias pd="pwd" // больше не нужно набирать это 'w'!
3. source ~/.bash_profile
```
##### Вывести все псевдонимы
```bash
alias -p
```

##### Unalias (например, после alias ls='ls --color=auto')
```bash
unalias ls
```

##### Установка и снятие опций оболочки
```bash
# вывести все опции оболочки
shopt

# для удаления (или остановки) псевдонимов
shopt -u expand_aliases

# для установки (или запуска) псевдонимов
shopt -s expand_aliases
```

##### Список переменных окружения (например, PATH)
```bash
echo $PATH
# список каталогов, разделенных двоеточием
```
##### Список всех переменных окружения для текущего пользователя
```bash
env
```
##### Сброс переменной окружения (например, сброс переменной 'MYVAR')
```bash
unset MYVAR
```

##### Показать формат раздела
```bash
lsblk
```

##### Информирование ОС об изменениях в таблице разделов
```bash
partprobe
```

##### Мягкая ссылка программы на bin
```bash
ln -s /path/to/program /home/usr/bin
# должен быть полный путь к программе
```

##### Показать шестнадцатеричное представление данных
```bash
hexdump -C filename.class
```

##### Перейти к другому узлу
```bash
rsh имя_узла
```

##### Проверка порта (активное интернет-соединение)
```bash
netstat -tulpn
```

##### Печать разрешенных символических ссылок или канонических имен файлов
```bash
readlink filename
```

##### Узнайте тип команды и ссылку на нее (например, python).
```bash
type python
# python это /usr/bin/python
# Существует 5 различных типов, проверьте их с помощью флага 'type -f'.
# 1. alias (псевдоним оболочки)
# 2. function (функция оболочки, тип также выводит тело функции)
# 3. builtin (встроенная функция оболочки)
# 4. file (дисковый файл)
# 5. keyword (зарезервированное слово оболочки)

# Вы также можете использовать `which
какой python
# /usr/bin/python
```

##### Список имен всех функций
```bash
объявить -F
```

##### Список общего размера каталога
```bash
du -hs .

# или
du -sb
```

##### Копирование каталога с установкой разрешения
```bash
cp -rp /path/to/directory
```

##### Сохранить текущий каталог
```bash
pushd .

# then pop
popd

#или используйте dirs для отображения списка текущих запомненных каталогов.
dirs -l
```

##### Показать использование диска
```bash
df -h

# или
du -h

# или
du -sk /var/log/* |sort -rn |head -10
```

##### проверьте использование Inode
```
df -i
# Файловая система Inodes IUsed IFree IUse% Mounted on
# devtmpfs 492652 304 492348 1% /dev
# tmpfs 497233 2 497231 1% /dev/shm
# tmpfs 497233 439 496794 1% /run
# tmpfs 497233 16 497217 1% /sys/fs/cgroup
# /dev/nvme0n1p1 5037976 370882 4667094 8% /
# tmpfs 497233 1 497232 1% /run/user/1000
```

##### Показать все типы файловых систем
```bash
df -TH
```

##### Показать текущий уровень выполнения
```bash
runlevel
```

##### Переключение уровня выполнения
```bash
init 3

#or
telinit 3
```

##### Постоянное изменение уровня выполнения
```bash
1. отредактируйте /etc/init/rc-sysinit.conf
2. env DEFAULT_RUNLEVEL=2
```

##### Стать root
```bash
su
```

##### Стать кем-то
```bash
su somebody
```

##### Сообщить о кавычках пользователя на устройстве
```bash
repquota -auvs
```

##### Получение записей в ряде важных баз данных
```bash
getent имя_базы_данных

# (например, база данных 'passwd')
getent passwd
# список всех учетных записей пользователей (всех локальных и LDAP)

# (например, получить список учетных записей grop)
getent group
# хранить в базе данных 'group'
```

##### Изменить владельца файла
```bash
chown имя_пользователя имя_файла
chown -R user_name /path/to/directory/
# chown user:group filename
```

##### Монтирование и размонтирование
```bash
# например, смонтировать /dev/sdb в /home/test
mount /dev/sdb /home/test

# например, размонтировать /home/test
umount /home/test
```

##### List current mount detail
```bash
mount
# или
df
```

##### Список текущих имен пользователей и номеров пользователей
```bash
cat /etc/passwd
```

##### Получить все имя пользователя
```bash
getent passwd| awk '{FS="[:]"; print $1}'
```

##### Показать всех пользователей
```bash
compgen -u
```

##### Показать все группы
```bash
compgen -g
```

##### Показать группу пользователя
```bash
имя пользователя группы
```

##### Показать uid, gid, группу пользователя
```bash
id имя пользователя

# переменная для UID
echo $UID
```

##### Проверьте, является ли он root
```bash
if [ $(id -u) -ne 0 ];then
    echo "Вы не root!"
    exit;
fi
# 'id -u' выводит 0, если вы не root
```

##### Узнать информацию о процессоре
```bash
more /proc/cpuinfo

# или
lscpu
```

##### Установите квоту для пользователя (например, мягкий лимит диска: 120586240; жесткий лимит: 125829120)
```bash
setquota username 120586240 125829120 0 0 /home
```

##### Показать квоту для пользователя
```bash
quota -v имя пользователя
```

##### Отображение текущих библиотек из кэша
```bash
ldconfig -p
```

##### Печать зависимостей общих библиотек (например, для 'ls')
```bash
ldd /bin/ls
```

##### Проверка входа пользователя в систему
```bash
lastlog
```
##### Проверка истории последних перезагрузок
```bash
последняя перезагрузка
```

##### Редактирование пути для всех пользователей
```bash
joe /etc/environment
# отредактируйте этот файл
```

##### Показать и установить лимит пользователей
```bash
ulimit -u
```

##### Выведите количество ядер/процессоров
```bash
nproc -all
```

##### Проверка состояния каждого ядра
```
1. верх
2. нажмите '1'
```

##### Показать задания и PID
```bash
jobs -l
```

##### Список всех запущенных служб
```bash
service --status-all
```

##### Запланируйте выключение сервера
```bash
shutdown -r +5 "Сервер будет перезапущен через 5 минут. Пожалуйста, сохраните свою работу."
```

##### Отмена запланированного выключения
```bash
shutdown -c
```

##### Трансляция всем пользователям
```bash
wall -n hihi
```

##### Убить все процессы пользователя
```bash
pkill -U имя_пользователя
```

##### Убить все процессы программы
```bash
kill -9 $(ps aux | grep 'имя_программы' | awk '{print $2}')
```

##### Установить привилегии gedit на сервере
```
# Возможно, вам придется установить следующее:

apt-get install libglib2.0-bin;
# или
yum install dconf dconf-editor;
yum install dbus dbus-x11;

# Проверить список
gsettings list-recursively

# Изменить некоторые настройки
gsettings set org.gnome.gedit.preferences.editor highlight-current-line true
gsettings set org.gnome.gedit.preferences.editor scheme 'cobalt'
gsettings set org.gnome.gedit.preferences.editor use-default-font false
gsettings set org.gnome.gedit.preferences.editor editor editor-font 'Cantarell Regular 12'
```
##### Добавьте пользователя в группу (например, добавьте пользователя 'nice' в группу 'docker', чтобы он мог запускать docker без sudo)
```bash
sudo gpasswd -a nice docker
```

##### Pip install python package without root
```bash
1. pip install --user имя_пакета
2. Вам может понадобиться экспортировать ~/.local/bin/ в PATH: export PATH=$PATH:~/.local/bin/
```

##### Удаление старых ядер linux (когда /boot почти заполнен...)
```bash
1. uname -a #проверьте текущее ядро, которое НЕ должно быть удалено
2. sudo apt-get purge linux-image-X.X.X-X-generic #заменить старую версию
```


##### Изменить имя хоста
```bash
sudo hostname your-new-name

# если не работает, сделайте также:
hostnamectl set-hostname your-new-hostname
# затем проверьте с помощью:
hostnamectl
# Или проверьте /etc/hostname

# Если все еще не работает..., отредактируйте:
/etc/sysconfig/network
/etc/sysconfig/network-scripts/ifcfg-ensxxx
#add HOSTNAME="your-new-hostname"
 ```

##### Список установленных пакетов
```bash
apt list -installed

# или на Red Hat:
yum list installed
```

##### Проверка обновления пакета
```bash
apt list -upgradeable

# или
sudo yum check-update
```

##### Запустите yum update, исключив пакет (например, не обновляйте пакет php).
```bash
sudo yum update --exclude=php*
```

##### Проверьте, какой файл делает устройство занятым при umount
```bash
lsof /mnt/dir
```

##### Когда звук не работает
```bash
killall pulseaudio
# затем нажмите Alt-F2 и введите pulseaudio
```

##### Когда звук не работает
```bash
killall pulseaudio
```

##### Список информации об устройствах SCSI
```bash
lsscsi
```

##### Руководство по настройке собственного DNS-сервера
http://onceuponmine.blogspot.tw/2017/08/set-up-your-own-dns-server.html

##### Учебник по созданию простого демона
http://onceuponmine.blogspot.tw/2017/07/create-your-first-simple-daemon.html

##### Учебник по использованию gmail для отправки электронной почты
http://onceuponmine.blogspot.tw/2017/10/setting-up-msmtprc-and-use-your-gmail.html

##### Использование telnet для проверки открытых портов, проверка возможности подключения к порту (например, 53) сервера (например, 192.168.2.106).
```bash
telnet 192.168.2.106 53
```

##### Изменение максимальной единицы передачи (mtu) сети (например, изменить на 9000)
```bash
ifconfig eth0 mtu 9000
```

##### Получение pid запущенного процесса (например, python)
```bash
pidof python

# или
ps aux|grep python
```

##### Проверка статуса процесса по PID
```bash
ps -p <PID>

#or
cat /proc/<PID>/status
cat /proc/<PID>/stack
cat /proc/<PID>/stat
```

##### NTP
```bash
# Запустите ntp:
ntpd

# Проверить ntp:
ntpq -p
```

##### Удалите ненужные файлы, чтобы очистить ваш сервер
```bash
sudo apt-get autoremove
sudo apt-get clean
sudo rm -rf ~/.cache/thumbnails/*

# Удалите старое ядро:
sudo dpkg --list 'linux-image*'
sudo apt-get remove linux-image-OLDER_VERSION
```

##### Увеличение/изменение размера корневого раздела (корневой раздел является логическим томом LVM)
```bash
pvscan
lvextend -L +130G /dev/rhel/root -r
# Добавление -r приведет к росту файловой системы после изменения размера тома.
```

##### Создайте загрузочный USB-накопитель UEFI (например, /dev/sdc1)
```bash
sudo dd if=~/path/to/isofile.iso of=/dev/sdc1 oflag=direct bs=1048576
```

##### Найдите и удалите пакет
```bash
sudo dpkg -l | grep <имя_пакета>
sudo dpkg --purge <имя_пакета>
```

##### Создание ssh-туннеля
```bash
ssh -f -L 9000:targetservername:8088 root@192.168.14.72 -N
#-f: работать в фоновом режиме; -L: слушать; -N: ничего не делать
#теперь 9000 вашего компьютера подключен к 8088 порту targetservername через 192.168.14.72
#так что вы можете увидеть содержимое targetservername:8088, введя localhost:9000 из вашего браузера.
```
##### Получение идентификатора процесса (например, sublime_text)
```bash
#pidof
pidof sublime_text

#pgrep, вам не нужно набирать имя программы целиком
pgrep sublim

#pgrep, эхо 1, если процесс найден, эхо 0, если такого процесса нет
pgrep -q sublime_text && echo 1 || echo 0

#top, занимает больше времени
top|grep sublime_text
```

##### Некоторые инструменты бенчмаркинга для вашего сервера
[aio-stress](https://openbenchmarking.org/test/pts/aio-stress) - бенчмарк AIO.  
[bandwidth](https://zsmith.co/bandwidth.html) - бенчмарк пропускной способности памяти.  
[bonnie++](https://www.coker.com.au/bonnie++/) - бенчмарк производительности жесткого диска и файловой системы.  
[dbench](https://dbench.samba.org/) - генерирование рабочих нагрузок ввода-вывода либо на файловую систему, либо на сетевой сервер CIFS или NFS.  
[dnsperf](https://www.dnsperf.com/) - авторизованные и рекурсивные DNS-серверы.  
[filebench](https://github.com/filebench/filebench) - генератор рабочих нагрузок файловой системы на основе модели.  
[fio](https://linux.die.net/man/1/fio) - бенчмарк ввода-вывода.  
[fs_mark](https://github.com/josefbacik/fs_mark) - эталон синхронного/асинхронного создания файлов.  
[httperf](https://github.com/httperf/httperf) - измерение производительности веб-сервера.  
[interbench](https://github.com/ckolivas/interbench) - бенчмарк интерактивности linux.  
[ioblazer](https://labs.vmware.com/flings/ioblazer) - мультиплатформенный микробенчмарк стека хранения данных.  
[iozone](http://www.iozone.org/) - бенчмарк файловой системы.  
[iperf3](https://iperf.fr/iperf-download.php) - измерение производительности TCP/UDP/SCTP.  
[kcbench](https://github.com/knurd/kcbench) - бенчмарк компиляции ядра, компилирует ядро и измеряет время, затраченное на это.  
[lmbench](http://www.bitmover.com/lmbench/) - набор простых, переносимых бенчмарков.  
[netperf](https://github.com/HewlettPackard/netperf) - измерение производительности сети, тестирование однонаправленной пропускной способности и сквозной задержки.  
[netpipe](https://linux.die.net/man/1/netpipe) - независимый оценщик производительности сетевых протоколов.  
[nfsometer](http://wiki.linux-nfs.org/wiki/index.php/NFSometer) - система оценки производительности NFS.  
[nuttcp](https://www.nuttcp.net/Welcome%20Page.html) - измерение производительности сети.  
[phoronix-test-suite](https://www.phoronix-test-suite.com/) - комплексная платформа автоматизированного тестирования и бенчмаркинга.  
[seeker](https://github.com/fidlej/seeker) - портативный бенчмарк поиска диска.  
[siege](https://github.com/JoeDog/siege) - тестер нагрузки http и бенчмарк.  
[sockperf](https://github.com/Mellanox/sockperf) - утилита сетевого бенчмаркинга через API сокетов.  
[spew](https://linux.die.net/man/1/spew) - измеряет производительность ввода-вывода и/или генерирует нагрузку на ввод-вывод.  
[stress](https://people.seas.harvard.edu/~apw/stress/) - генератор рабочей нагрузки для POSIX-систем.  
[sysbench](https://github.com/akopytov/sysbench) - скриптовый эталон производительности баз данных и систем.  
[tiobench](https://github.com/mkuoppal/tiobench) - эталон потокового ввода-вывода.  
[unixbench](https://github.com/kdlucas/byte-unixbench) - оригинальный набор эталонов BYTE UNIX, обеспечивает базовый показатель производительности Unix-подобной системы.  
[wrk](https://github.com/wg/wrk) - эталон HTTP.  


##### Инструмент мониторинга производительности - sar
```bash
# установка
# Он собирает данные каждые 10 минут и генерирует отчет ежедневно. За сбор и генерацию отчетов отвечает файл crontab (/etc/cron.d/sysstat).
yum install sysstat
systemctl start sysstat
systemctl enable sysstat

# показывает загрузку процессора 5 раз каждые 2 секунды.
sar 2 5

# показать использование памяти 5 раз каждые 2 секунды.
sar -r 2 5

# показывать статистику подкачки 5 раз каждые 2 секунды.
sar -B 2 5

# Вывести всю сетевую статистику:
sar -n ALL

# чтение файла журнала SAR с помощью команды -f
sar -f /var/log/sa/sa31|tail
```

##### Чтение из файла журнала
```bash
journalctl --file ./log/journal/a90c18f62af546ccba02fa3734f00a04/system.journal --since "2020-02-11 00:00:00"
```

##### Показать список последних вошедших в систему пользователей.
```bash
lastb
```

##### Показать список текущих вошедших пользователей, распечатать информацию о них
```bash
who
```
##### Показать, кто вошел в систему и что он делает.
```bash
w
```

##### Выведите имена пользователей, вошедших в систему на текущем хосте.
```bash
users
```

##### Остановка хвоста файла при завершении программы
```bash
tail -f --pid=<PID> filename.txt
# замените <PID> на идентификатор процесса программы.
```

##### Список всех включенных служб
```bash
systemctl list-unit-files|grep enabled
```


## Hardware
[[назад к началу](#handy-bash-one-liners)]

##### Соберите и обобщите всю информацию об аппаратном обеспечении вашей машины.
```bash
lshw -json >report.json
# Другие опции: [ -html ] [ -short ] [ -xml ] [ -json ] [ -businfo ] [ -sanitize ] и т.д.
```

##### Выяснение деталей устройства памяти
```bash
sudo dmidecode -t memory
```

##### Вывод подробной информации об аппаратном обеспечении процессора
```bash
dmidecode -t 4
# Информация о типе
# 0 BIOS
# 1 Система
# 2 Базовая плата
# 3 Шасси
# 4 Процессор
# 5 Контроллер памяти
# 6 Модуль памяти
# 7 Кэш
# 8 Разъем порта
# 9 Системные слоты
# 11 OEM-строки
# 13 Язык BIOS
# 15 Журнал системных событий
# 16 Массив физической памяти
# 17 Устройство памяти
# 18 Ошибка 32-битной памяти
# 19 Адрес сопоставления массива памяти
# 20 Адрес сопоставления устройства памяти
# 21 Встроенное указательное устройство
# 22 Портативная батарея
# 23 Сброс системы
# 24 Аппаратная безопасность
# 25 Управление питанием системы
# 26 Щуп напряжения
# 27 Устройство охлаждения
# 28 Датчик температуры
# 29 Щуп электрического тока
# 30 Внеполосный удаленный доступ
# 31 Службы целостности загрузки
# 32 Загрузка системы
# 34 Устройство управления
# 35 Компонент устройства управления
# 36 Пороговые данные устройства управления
# 37 Канал памяти
# 38 Устройство IPMI
# 39 Источник питания
```
##### Подсчитайте количество жестких дисков Segate.
```bash
lsscsi|grep SEAGATE|wc -l
# или
sg_map -i -x|grep SEAGATE|wc -l
```

##### Получение UUID диска (например, sdb)
```bash
lsblk -f /dev/sdb

# или
sudo blkid /dev/sdb
```

##### Сгенерируйте UUID
```bash
uuidgen
```

##### Печать подробной информации обо всех жестких дисках
```bash
lsblk -io KNAME,TYPE,MODEL,VENDOR,SIZE,ROTA
#где ROTA означает вращающееся устройство / вращающиеся жесткие диски (1 - если истинно, 0 - если ложно)
```

##### Список всех устройств PCI (Peripheral Component Interconnect)
```bash
lspci
# Список информации о сетевой карте
lspci | egrep -i --color 'network|ethernet'
```

##### Список всех USB-устройств
```bash
lsusb
```

##### Модули Linux
```bash
# Показать статус модулей в ядре Linux
lsmod

# Добавление и удаление модулей из ядра Linux
modprobe

# или
# Удалить модуль
rmmod

# Вставить модуль
insmod
```

##### Управление устройствами с поддержкой IPMI (например, BMC)
```bash
# Удаленное выяснение состояния питания сервера
ipmitool -U <bmc_username> -P <bmc_password> -I lanplus -H <bmc_ip_address> power status

# Удаленное включение сервера
ipmitool -U <bmc_username> -P <bmc_password> -I lanplus -H <bmc_ip_address> power on

# Включите индикатор идентификации панели (по умолчанию 15 с)
ipmitool chassis identify 255

# Узнайте температуру датчиков сервера
ipmitool sensors |grep -i Temp

# Сброс BMC
ipmitool bmc reset cold

# Prnt BMC network
ipmitool lan print 1

# Настройка сети BMC
ipmitool -I bmc lan set 1 ipaddr 192.168.0.55
ipmitool -I bmc lan set 1 netmask 255.255.255.0
ipmitool -I bmc lan set 1 defgw ipaddr 192.168.0.1
```


## Networking
[[назад к началу](#handy-bash-one-liners)]

##### Разрешить домен в IP-адрес(ы)
```bash
dig +short www.example.com

# или
хост www.example.com
```

##### Получение DNS TXT записи a домена.
```bash
dig -t txt www.example.com

# или
host -t txt www.example.com
```

##### Отправьте ping с ограничением TTL до 10 (TTL: Time-To-Live, это максимальное количество переходов, которое пакет может пройти через Интернет, прежде чем будет отброшен).
```bash
ping 8.8.8.8 -t 10
```

##### Печать трассировки маршрутных пакетов до узла сети
```bash
traceroute google.com
```

##### Проверка соединения с хостом (например, проверка соединения с 80 и 22 портом google.com)
```bash
nc -vw5 google.com 80
# Подключение к 80 порту [tcp/http] google.com успешно!

nc -vw5 google.com 22
# nc: соединение с google.com порт 22 (tcp) прервано: Операция продолжается
# nc: connect to google.com port 22 (tcp) failed: Network is unreachable
```

##### Nc как инструмент чата!
```bash
# С сервера A:
$ sudo nc -l 80
# затем вы можете подключиться к порту 80 с другого сервера (например, сервера B):
# например, telnet <IP-адрес сервера A> 80
# затем введите что-нибудь на сервере B.
# и вы увидите результат на сервере A!
```

##### Проверьте, какие порты слушают TCP соединения из сети.
```bash
#заметьте, что некоторым компаниям может не понравиться, что вы используете nmap
nmap -sT -O localhost

# проверьте порт 0-65535
nmap -p0-65535 localhost
```
##### Проверка работоспособности хоста и сканирование открытых портов, также пропуск обнаружения хоста.
```bash
#пропускает проверку, жив ли хост, что иногда может вызвать ложное срабатывание и остановить сканирование.
$ nmap google.com -Pn

# Пример вывода:
# Starting Nmap 7.01 ( https://nmap.org ) at 2020-07-18 22:59 CST
# Отчет о сканировании Nmap для google.com (172.217.24.14)
# Host is up (0.013s latency).
# Другие адреса для google.com (не сканировались): 2404:6800:4008:802::200e
# Запись rDNS для 172.217.24.14: tsa01s07-in-f14.1e100.net
# Не показано: 998 отфильтрованных портов
# ОБСЛУЖИВАНИЕ СОСТОЯНИЯ ПОРТА
# 80/tcp open http
# 443/tcp open https
#
# Nmap done: 1 IP-адрес (1 хост) отсканирован за 3,99 секунды
```
##### Сканирование на наличие открытых портов и определение ОС и версии (например, сканирование домена "scanme.nmap.org")
```bash
$ nmap -A -T4 scanme.nmap.org
# -A для включения обнаружения ОС и версий, сканирования скриптов и traceroute; -T4 для более быстрого выполнения
```

##### Поиск информации о сайте (например, сервера имен), поиск объекта в базе данных RFC 3912.
```bash
whois google.com
```

##### Показать SSL-сертификат домена
```bash
openssl s_client -showcerts -connect www.example.com:443
```

##### Показать IP-адрес
```bash
ip a
```

##### Отображение таблицы маршрутов
```bash
ip r
```

##### Отображение ARP-кэша (ARP-кэш отображает MAC-адреса устройств в той же сети, к которой вы подключились)
```bash
ip n
```

##### Добавить переходные IP-адреса (сбрасываются после перезагрузки) (например, добавить 192.168.140.3/24 к устройству eno16777736)
```bash
ip address add 192.168.140.3/24 dev eno16777736
```

##### Сохранение изменений конфигурации сети
```bash
sudo vi /etc/sysconfig/network-scripts/ifcfg-enoxxx
# затем отредактируйте поля: BOOTPROT, DEVICE, IPADDR, NETMASK, GATEWAY, DNS1 и т.д.
```
##### Refresh NetworkManager
```bash
sudo nmcli c reload
```

##### Перезапустите все интерфейсы
```bash
sudo systemctl restart network.service
```

##### Для одновременного просмотра имени хоста, ОС, ядра, архитектуры!
```bash
hostnamectl
```

##### Установить имя хоста (установить все переходные, статические, красивые имена хостов сразу)
```bash
hostnamectl set-hostname "mynode"
```

##### Выяснить веб-сервер (например, Nginx или Apache) веб-сайта.
```bash
curl -I http://example.com/
# HTTP/1.1 200 OK
# Сервер: nginx
# Date: Thu, 02 Jan 2020 07:01:07 GMT
# Content-Type: text/html
# Content-Length: 1119
# Connection: keep-alive
# Vary: Accept-Encoding
# Last-Modified: Mon, 09 Sep 2019 10:37:49 GMT
# ETag: "xxxxxx"
# Accept-Ranges: bytes
# Vary: Accept-Encoding
```

##### Узнайте http код состояния URL-адреса
```bash
curl -s -o /dev/null -w "%{http_code}" https://www.google.com
```

##### Сокращение сокращенного URL-адреса
```bash
curl -s -o /dev/null -w "%{redirect_url}" https://bit.ly/34EFwWC
```

##### Проведите тесты пропускной способности сети
```bash
# серверная сторона:
$ sudo iperf -s -p 80

# клиентская сторона:
iperf -c <IP-адрес сервера> --parallel 2 -i 1 -t 2 -p 80
```

##### Чтобы заблокировать порт 80 (HTTP-сервер) с помощью iptables.
```bash
sudo iptables -A INPUT -p tcp --dport 80 -j DROP

# блокировать соединение только с IP-адреса
sudo iptables -A INPUT -s <IP> -p tcp -dport 80 -j DROP
```

## Обработка данных
[[назад к началу](#handy-bash-one-liners)]

##### Выведите некоторые слова, которые начинаются с определенной строки (например, слова, начинающиеся с 'phy')
```bash
# Если файл не указан, используется файл /usr/share/dict/words.
look phy|head -n 10
# phycic
# Phyciodes
# phycite
# Phycitidae
# phycitol
# phyco-
# phycochrom
# phycochromaceae
# phycochromaceous
# фикохром
```

##### Повторите печать строки n раз (например, напечатайте "hello world" пять раз)
```bash
printf 'hello world\n%.0s' {1..5}
```
##### Не выводить эхом завершающую новую строку.
```bash
username=`echo -n "bashoneliner"`
```

##### Копирование файла в несколько файлов (например, копирование файлаА в файл(B-D))
```bash
tee <fileA fileB fileC fileD >/dev/null
```

##### Удалить все непечатные символы
```bash
tr -dc '[:print:]' < имя файла
```

##### Удалить новую строку / следующую строку
```bash
tr --delete '\n' <input.txt >output.txt
```
##### Заменить новую строку
```bash
tr '\n' ' ' <filename
```

##### В прописные/строчные буквы
```bash
tr /a-z/ /A-Z/

```
##### Перевести диапазон символов (например, заменить a-z на a)
```bash
echo 'something' |tr a-z a
# aaaaaaaaaaa
```

##### Сравнить два файла (например, файлА, файлВ)

```bash
diff fileA fileB
# a: добавлено; d:удалено; c:изменено

# или
sdiff fileA fileB
# слияние различий файлов по бокам
```

##### Сравните два файла, удалите возврат каретки/следующую строку (например, fileA, fileB)
```bash
diff fileA fileB --strip-trailing-cr
```

##### Найти общие/различающиеся строки
```bash
# имея два отсортированных и унифицированных файла (например, после выполнения команды `$ sort -uo fileA fileA` и то же самое для файлаB):
# ---
# fileA:
# ---
# joey
# котенок
# поросёнок
# щенок
# ---
# fileB:
# ---
# теленок
# птенец
# мальчик
# щенок
#
# Найдите строки в обоих файлах
comm -12 fileA fileB
# joey
# щенок
#
# Найдите строки в файлеB, которые НЕ находятся в файлеA
comm -13 fileA fileB
# теленок
# птенец
#
# Найдите строки в файлеА, которые НЕ находятся в файлеВ
comm -23 fileA fileB
# котенок
# поросёнок
```

##### Номер файла (например, fileA)

```bash
nl fileA

#or
nl -nrz fileA
# добавить ведущие нули

#or
nl -w1 -s ' '
# упростить, отделить пустые строки
```

##### Объедините два файла по полям с помощью табуляции (по умолчанию объединение происходит по первому столбцу обоих файлов, а разделителем по умолчанию является пробел)
```bash
# файлА и файлВ должны иметь одинаковый порядок строк.
join -t '\t' fileA fileB

# Объединить, используя указанное поле (например, столбец 3 файлаА и столбец 5 файлаВ)
join -1 3 -2 5 fileA fileB
```

##### Объединить/вставить два или более файлов в колонки (например, fileA, fileB, fileC)
```bash
paste fileA fileB fileC
# default tab separate
```

##### Группировка/объединение строк в одну строку
```bash
# например.
# AAAA
# BBBB
# CCCC
# DDDD
cat filename|paste - -
# AAAABBBB
# CCCCDDDD
cat filename|paste - - - - - -
# AAAABBBBBCCCCDDDDDD
```

##### Fastq в fasta (fastq и fasta - распространенные форматы файлов для данных последовательности в биоинформатике)
```bash
cat file.fastq | paste - - - - - | sed 's/^@/>/g'| cut -f1-2 | tr '\t' '\n' >file.fa
```

##### Обратная строка
```bash
echo 12345| rev
```

##### Генерирование последовательности 1-10
```bash
seq 10
```

##### Найдите среднее значение входного списка/файла целых чисел
```bash
i=`wc -l filename|cut -d ' ' -f1`; cat filename| echo "scale=2;(`paste -sd+`)/"$i|bc
```

##### Сгенерируйте все комбинации (например, 1,2)
```bash
echo {1,2}{1,2}
# 1 1, 1 2, 2 1, 2 2
```

##### Сгенерируйте все комбинации (например, A,T,C,G)
```bash
set = {A,T,C,G}
группа = 5
for ((i=0; i<$group; i++));do
    repetition=$set$repetition;done
    bash -c "echo "$repetition""
```

##### Чтение содержимого файла в переменную
```bash
foo=$(<test1)
```

##### Вывод размера переменной
```bash
echo ${#foo}
```

##### Эхо табуляции
```bash
echo -e ' \t '
```

##### Разделить файл на меньший файл
```bash
# Разделение по строкам (например, 1000 строк/большой файл)
split -d -l 1000 bigfile.txt

# Разделение по байтам без разрыва строк между файлами
split -C 10 bigfile.txt
```

##### Создайте большое количество фиктивных файлов (например, 100000 файлов, по 10 байт каждый):
```bash
#1. Создайте большой файл
dd if=/dev/zero of=bigfile bs=1 count=1000000

#2. Разделите большой файл на 100000 10-байтовых файлов
 split -b 10 -a 10 bigfile
```

##### Переименуйте все файлы (например, удалите ABC из всех .gz файлов)
```bash
rename 's/ABC//' *.gz
```

##### Удалить расширение файла (например, удалить .gz из файла filename.gz)
```bash
basename filename.gz .gz

zcat filename.gz> $(basename filename.gz .gz).unpacked
```

##### Добавьте расширение файла ко всем файлам (например, добавьте .txt)
```bash
rename s/$/.txt/ *
# Вы можете использовать команду rename -n s/$/.txt/ * для проверки результата, она выведет только что-то вроде этого:
# rename(a, a.txt)
# rename(b, b.txt)
# rename(c, c.txt)
```

##### Выдавливание повторяющихся паттернов (например, /t/t --> /t)
```bash
tr -s "/t" < имя файла
```

##### Не печатать следующую строку с помощью echo
```bash
echo -e 'текст здесь \c'
```

##### Просмотр первых 50 символов файла
```bash
head -c 50 file
```

##### Вырезать и получить последний столбец файла
```bash
cat file|rev | cut -d/ -f1 | rev
```

##### Добавление единицы к переменной/увеличение/ i++ числовой переменной (например, $var)
```bash
((var++))
# или
var=$((var+1))

```
##### Вырежьте последний столбец
```bash
cat filename|rev|cut -f1|rev
```

##### Кошка в файл
```bash
cat >myfile
позвольте мне добавить кое-что
выход по control + c
^C
```

##### Очистить содержимое файла (например, имя файла)
```bash
>filename
```

##### Добавить в файл (например, hihi)
```bash
echo 'hihi' >>filename
```

##### Работа с json данными
```bash
#установите полезный пакет jq
#sudo apt-get install jq
#Например, чтобы получить все значения ключа 'url', просто передайте json в следующую команду jq (вы можете использовать .[]. для выбора внутреннего json, т.е. jq '.[].url')
cat file.json | jq '.url'
```

##### Десятичная система счисления в двоичную (например, получить двоичное число 5)
```bash
D2B=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1})
echo -e ${D2B[5]}
#00000101
echo -e ${D2B[255]}
#11111111
```

##### Оберните каждую строку ввода, чтобы она поместилась в указанную ширину (например, 4 целых числа на строку)
```bash
echo "00110010101110001101" | fold -w4
# 0011
# 0010
# 1011
# 1000
# 1101
```

##### Сортировка файла по столбцам с сохранением исходного порядка
```bash
sort -k3,3 -s
```

##### Выравнивание столбца по правому краю (выравнивание по правому краю 2-го столбца)
```bash
cat file.txt|rev|column -t|rev
```

##### Для просмотра и сохранения вывода
```bash
echo 'hihihihi' | tee outputfile.txt
# используйте '-a' с tee для добавления в файл.
```

##### Показать непечатные символы (Ctrl) с помощью cat
```bash
cat -v имя файла
```

##### Преобразование табуляции в пробел
```bash
расширить имя файла
```

##### Преобразование пробела в табуляцию
```bash
раскрыть имя файла
```

##### Отображение файла в восьмеричной системе счисления (вы также можете использовать od для отображения шестнадцатеричной, десятичной и т.д.)
```bash
od имя файла
```

##### Перевернуть файл в формате cat
```bash
tac имя файла
```

##### Обратный результат от `uniq -c`
```bash
while read a b; do yes $b |head -n $a ;done <test.txt
```


## Другие
[[назад к началу](#handy-bash-one-liners)]

##### Опишите формат и характеристики файлов изображений.
```bash
определить myimage.png
#myimage.png PNG 1049x747 1049x747+0+0 8-bit sRGB 1.006MB 0.000u 0:00.000
```

##### Bash auto-complete (например, показывать варианты "now tomorrow never", когда вы нажимаете 'tab' после ввода "dothis")
[Больше примеров](https://iridakos.com/tutorials/2018/03/01/bash-programmable-completion-tutorial.html)
```bash
complete -W "now tomorrow never" dothis
# ~$ dothis  
# никогда сейчас завтра
# нажмите 'tab' снова для автозаполнения после ввода 'n' или 't'
```
##### Отображает календарь
```bash
# выведите текущий месяц, сегодняшний будет выделен.
cal
# October 2019      
# Su Mo Tu We Th Fr Sa  
# 1 2 3 4 5  
# 6 7 8 9 10 11 12  
# 13 14 15 16 17 18 19  
# 20 21 22 23 24 25 26  
# 27 28 29 30 31  

# отображать только ноябрь
cal -m 11
```

##### Преобразуйте шестнадцатеричное значение контрольной суммы MD5 в его base64-кодированный формат.
```bash
openssl md5 -binary /path/to/file| base64
# NWbeOpeQbtuY0ATWuUeumw==
```

##### Заставляет приложения использовать язык по умолчанию для вывода.
```bash
export LC_ALL=C

# для возврата:
unset LC_ALL
```
##### Кодирование строк как строк Base64
```bash
echo test|base64
#dGVzdAo=
```

##### Получение родительского каталога текущего каталога
```bash
dirname `pwd`
```

##### Чтение .gz файла без извлечения

```bash
zmore имя файла

# или
zless filename
```

##### Выполнение команды в фоновом режиме, вывод файла ошибок
```bash
some_commands &>log &

# или
some_commands 2>log &

# или
some_commands 2>&1| tee logfile

# или
some_commands |& tee logfile

# или
some_commands 2>&1 >>outfile
#0: стандартный ввод; 1: стандартный вывод; 2: стандартная ошибка
```

##### Выполнение нескольких команд в фоновом режиме
```bash
# запускать последовательно
(sleep 2; sleep 3) &

# выполнять параллельно
sleep 2 & sleep 3 &
```

##### Запуск процесса даже при выходе из системы (невосприимчивость к зависаниям, с выводом на не-tty)
```bash
# Например, запустите myscript.sh даже при выходе из системы.
nohup bash myscript.sh
```

##### Отправка почты
```bash
echo 'вот содержимое'| mail -a /path/to/attach_file.txt -s 'mail.subject' me@gmail.com
# используйте флаг -a для установки отправки от (-a "From: some@mail.tld")
```

##### Преобразование .xls в csv
```bash
xls2csv имя файла
```

##### Сделать звук BEEP
```bash
speaker-test -t sine -f 1000 -l1
```

##### Установите длительность звукового сигнала
```bash
(speaker-test -t sine -f 1000) & pid=$!;sleep 0.1s;kill -9 $pid
```

##### Редактирование своей истории
```bash
история -w
vi ~/.bash_history
history -r

#or
history -d [номер_строки]
```

##### Взаимодействие с историей
```bash
# список 5 предыдущих команд (аналогично `history |tail -n 5`, но не выводит саму команду history)
fc -l -5
```

##### Удаление текущей команды bash
```bash
Ctrl+U

# или
Ctrl+C

# или
Alt+Shift+#
# чтобы перейти к истории
```

##### Добавить что-то в историю (например, "addmetohistory")
```bash
# addmetodistory
# просто добавьте "#" перед~~.
```

##### Получить имя файла последней истории/записи.
```bash
head !$
```

##### Очистить экран
```bash
clear
# или просто Ctrl+l
```

##### Резервное копирование с помощью rsync
```bash
rsync -av filename filename.bak
rsync -av directory directory.bak
rsync -av --ignore_existing directory/ directory.bak
rsync -av --update directory directory.bak

rsync -av directory user@ip_address:/path/to/directory.bak
# пропускать файлы, которые новее на приемнике (я предпочитаю этот вариант!)
```

##### Сделайте все каталоги за один раз!
```bash
mkdir -p project/{lib/ext,bin,src,doc/{html,info,pdf},demo/stat}
# -p: сделать родительский каталог
# это создаст project/doc/html/; project/doc/info; project/lib/ext и т.д.
```

##### Выполняйте команду, только если другая команда возвращает нулевой статус выхода (хорошо сделано)
```bash
cd tmp/ && tar xvf ~/a.tar
```

##### Выполнение команды только в том случае, если другая команда возвращает ненулевой статус выхода (не закончено)
```bash
cd tmp/a/b/c ||mkdir -p tmp/a/b/c
```

##### Используйте обратную косую черту "\", чтобы прервать длинную команду
```bash
cd tmp/a/b/c \
> || \
>mkdir -p tmp/a/b/c
```

##### Перечислите тип файла (например, /tmp/)
```bash
file /tmp/
# tmp/: каталог
```

##### Написание сценария Bash ('#!' называется shebang )
```bash
#!/bin/bash
file=${1#*.}
# удалить строку перед "."
```

##### Python простой HTTP сервер
```bash
python -m SimpleHTTPServer
# или при использовании python3:
python3 -m http.server
```

##### Чтение пользовательского ввода
```bash
чтение ввода
echo $input
```

##### Массив
```bash
declare -a array=()

# или
declare array=()

# или ассоциативный массив
declare -A array=()
```

##### Отправить каталог
```bash
scp -r directoryname user@ip:/path/to/send
```

##### Fork bomb
```bash
# Не пытайтесь сделать это дома!
# Это функция, которая вызывает себя дважды при каждом вызове, пока не закончатся системные ресурсы.
# '# ' добавляется спереди для безопасности, удалите его, когда будете серьезно тестировать.
# :(){:|:&};:
```

##### Используйте последний аргумент
```bash
!$
```

##### Проверка последнего кода выхода
```bash
echo $?
```

##### Извлечение .xz
```
unxz filename.tar.xz
# тогда
tar -xf filename.tar
```

##### Разархивируйте файл tar.bz2 (например, file.tar.bz2)
```bash
tar xvfj file.tar.bz2
```

##### Разархивировать файл tar.xz (например, file.tar.xz)
```bash
unxz file.tar.xz
tar xopf file.tar
```
##### Извлечь по пути
```bash
tar xvf -C /path/to/directory filename.gz
```

##### Запилить содержимое каталога, не включая сам каталог
```bash
# Сначала перейдите в каталог, затем запустите:
zip -r -D ../myzipfile .
# Вы увидите myzipfile.zip в родительском каталоге (cd ...)
```

##### Выводим y/n несколько раз, пока не будет убит.
```bash
# 'y':
yes

# или 'n':
yes n

# или 'anything':
да что угодно

# передайте yes в другую команду
yes | rm -r big_directory
```

##### Мгновенно создайте большой фиктивный файл определенного размера (например, 10GiB).
```bash
fallocate -l 10G 10Gigfile
```

##### Создать фиктивный файл определенного размера (например, 200мб)
```bash
dd if=/dev/zero of=//dev/shm/200m bs=1024k count=200
# или
dd if=/dev/zero of=//dev/shm/200m bs=1M count=200

# Стандартный вывод:
# 200+0 записей in
# 200+0 записей на выходе
# 209715200 байт (210 МБ) скопировано, 0.0955679 с, 2.2 ГБ/с
```

##### Продолжайте /повторяйте выполнение одной и той же команды (например, повторяйте 'wc -l filename' каждые 1 секунду)
```bash
watch -n 1 wc -l filename
```

##### Выводить команды и их аргументы при выполнении (например, echo `expr 10 + 20`)
```bash
set -x; echo `expr 10 + 20`
```

##### Выведите несколько осмысленных предложений (сначала установите fortune)
```bash
fortune
```

##### Красочная (и полезная) версия top (сначала установите htop)
```bash
htop
```

##### Нажмите любую клавишу, чтобы продолжить
```bash
read -rsp $'Нажмите любую клавишу для продолжения...\n' -n1 key
```

##### Выполните sql-подобную команду над файлами из терминала
```bash
# download:
# https://github.com/harelba/q
# пример:
q -d "," "select c3,c4,c5 from /path/to/file.txt where c3='foo' and c5='boo'"
```

##### Использование Screen для нескольких терминальных сессий
```bash
# Создайте сессию и подключите ее:
screen

# Создайте экран и назовите его 'test'
screen -S test

# Создать отделенную сессию foo:
screen -S foo -d -m

# Отсоединенная сессия foo:
screen: ^a^d

# Список сессий:
screen -ls

# Присоединить последнюю сессию:
screen -r

# Прикрепить к сеансу foo:
screen -r foo

# Убить сессию foo:
screen -r foo -X quit


# Прокрутка:
# Нажмите комбинацию префиксов экрана (C-a / control+A), затем нажмите Escape.
# Перемещение вверх/вниз с помощью клавиш со стрелками (↑ и ↓).  

# Перенаправить вывод уже запущенного процесса в Screen:
# (C-a / control+A), затем нажмите 'H'.  

# Сохранить вывод экрана для Screen:
# Ctrl+A, Shift+H  
# Вы найдете файл screen.log в текущем каталоге.  
```

##### Использование Tmux для нескольких терминальных сессий
```bash
# Создайте сессию и подключите ее:
tmux

# Присоединить к сессии foo:
tmux attach -t foo

# Отсоединить сессию foo:
^bd

# Список сессий:
tmux ls

# Присоединить последнюю сессию:
tmux attach

# Убить сессию foo:
tmux kill-session -t foo

# Создать отделенную сессию foo:
tmux new -s foo -d

# Отправьте команду всем панелям в tmux:
Ctrl-B
:setw synchronize-panes

# Некоторые команды управления панелями tmux:
Ctrl-B
# Панели (сплиты), Нажмите Ctrl+B, затем введите следующий символ:
# % горизонтальное разделение
# вертикальное разделение
# o поменять панели местами
# q показать номера панелей
# x - закрыть панель
# пробел - переключение между макетами

# Распределить по вертикали (ряды):
select-layout even-vertical
# или
Ctrl+b, Alt+2

# Распределить по горизонтали (столбцы):
select-layout even-horizontal
# или
Ctrl+b, Alt+1

# Прокрутка
Ctrl-b, затем \[ затем вы можете использовать обычные навигационные клавиши для прокрутки.
Нажмите q, чтобы выйти из режима прокрутки.
```

##### Передайте пароль для ssh
```bash
sshpass -p mypassword ssh root@10.102.14.88 "df -h"
```

##### Ожидание завершения pid (задания)
```bash
wait %1
# или
ждать $PID
wait ${!}
#wait ${!} для ожидания последнего фонового процесса ($! - PID последнего фонового процесса)
```

##### Преобразование pdf в txt
```bash
sudo apt-get install poppler-utils
pdftotext example.pdf example.txt
```

##### Список только директорий
```bash
ls -d */
```

##### Перечислять по одному файлу в строке.
```bash
ls -1
# или перечислить все, не игнорируйте записи, начинающиеся с .
ls -1a
```

##### Захват/запись/сохранение вывода терминала (захват всего, что вы вводите и выводите)
```bash
script output.txt
# начните использовать терминал
# чтобы выйти из экранной сессии (прекратить сохранение содержимого), введите exit.
```

##### Перечислите содержимое каталогов в древовидном формате.
```bash
tree
# перейдите в каталог, который вы хотите перечислить, и введите tree (sudo apt-get install tree)
# output:
# home/
# └── project
# ├── 1
# ├── 2
# ├── 3
# ├── 4
# └── 5
#

# установите каталоги уровней вглубь (например, уровень 1)
tree -L 1
# home/
# └── проект
```

##### Установите virtualenv(sandbox) для python.
```bash
# 1. установите virtualenv.
sudo apt-get install virtualenv
# 2. Создайте каталог (назовите его .venv или любым другим именем) для вашей новой блестящей изолированной среды.
virtualenv .venv
# 3. источник virtual bin
source .venv/bin/activate
# 4. Вы можете проверить, находитесь ли вы теперь внутри песочницы.
type pip
# 5. Теперь вы можете установить ваш пакет pip, здесь requirements.txt - это просто txt-файл, содержащий все пакеты, которые вам нужны. (например, tornado==4.5.3).
pip install -r requirements.txt
# 6. Выйдите из виртуальной среды
деактивировать
```



> Дальше будет больше!!!